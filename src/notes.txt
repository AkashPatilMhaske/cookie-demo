Polymorphism :
- poly: many
- morph : forms

- It is an ability of an object to changes its behaviour either at compile time or run time.

- Compile time polymorphism / static binding / early binding /
    - we achieve compile time polymorphism with method overloading

- Run time polymorphism / dynamic binding / late binding /
    - we achieve run time polymorphism with method overriding

What do you mean by object behaviour change?
- Every object has
    - state / fields / attributes / columns / variables / instance variables
    - behaviour / method / function / procedure / implementation / task / instance methods / forms

- Behaviour change means changing the method body by keeping method name same.
------------------------------------------------------------------------------------------------------------

Method overloading :
- it is a process of defining multiple methods with same name and
    different signature( either type of parameters or no. of parameters)

- We can overload private methods
- We can overload static methods
- We can overload final methods
- We can overload main method.
- We can overload constructors.

We do not consider return type for the method overloading.
- In method overloading, call to the method is decided at compile time.

** method overloading can happen in the same class as well as Parent- Child class

Method overloading:
    - We can define the method in the child class with the same name,
     - but different signature as of Parent class method.

------------------------------------------------------------------------------------------------------------
Method overrding:
    - It is a process of defining a method in the child class with the
        - same name
        - same signature
        - same return type
        as of Parent class method.
class A{
    void m1(){}
}
class B extends A{
    void m1(){}
}

Why do we go with the method overrding?
- If we are not happy with the parent class implementation

Rules :
    1. We can't override private methods
    2. We can't override static methods
    3. We can't override final methods
    4. We can increase the method access specifier scop but can't do demotion
        private > default > protected > public
        e.g if parent class is having method visibility to public, then child class method must be public
------------------------------------------------------------------------------------------------------------
final keyword :
- we can apply final keyword for variables, methods, class
1. if a variable is final, we cannot reassign the value.
2. if a method is final, we can't override it
3. if a class final, we can't extend it.
4. If instance variable are final, then they should initialized either in the same line or in the constructor.
5. If static variable are final, then they should initialized either in the same line or in the static block.
- If a reference variable is final, it means it will always point to the same object.
- We can change the object content
------------------------------------------------------------------------------------------------------------
What is an Immutable class?
- It is a class where once object is created we cannot change the content of an object.
e.g. String, all wraper classes[Byte, Short, Integer, Character, Long]

To make any class immutable,
1. We make the class final
2. we make the class members private
3. We do not public setters.

We can create the object of an immutable class
------------------------------------------------------------------------------------------------------------

Concrete method : method which has implementation[body {}]
Concrete class :
    - A class which contains only concrete methods.
    - A normal java class i.e. concrete class cannot have incomplete methods i.e. abstract methods
    - If we write abstract method in a concrete class we ge CTE

Abstraction : It is a process of exposing the functionality and hiding the implementation[method body] details.
Q. How do we achieve abstraction?
A. We achieve abstraction with the help of abstract class and interface.

abstract method :
    - A method which does not have method body and declared with the help of abstract keyword.
         e.g. abstract void m1();
    - an abstract method cannot be written inside the concrete class.
    - We can define abstract method inside the abstract class or interface
    - A method cannot be both abstract and final. Either It can be abstract or final not both

# abstract class :
- A class which is created with abstract keyword.
- e.g, abstract class A {}
- We use abstract class to define abstract methods.
- It is optional to write abstract methods inside the abstract class or an interface.
- we can have empty abstract class.
- A class cannot be both abstract and final. Either It can be abstract or final not both
- An abstract class can contain everything from concrete class + abstract methods

Q. Can we create the object of an abstract class?
A. No. By writing the abstract keyword, we tell compiler that it is an incomplete
   So we can't create object even though class is empty.

Q. Can we write main method inside the abstract class?
A. We can write.

Since we cannot create the object of an abstract class, how can we call abstract class constructor?

-- When a concrete class extends another abstract class, then in the concrete class we must override abstract methods.
- When one abstract class extends another abstract class, then it is optional for the child class to override abstract methods.

Q. How can we call constructor of the abstract class?
A. - Create a concrete subclass then create the object.
   - From child class constructor, it will call abstract class constructor.


# Disadvantages with Abstract class:
1. We can not achieve multiple inheritance
2. We can not achieve 100% abstraction. Even though class is abstract there is not guarantee that it will have only abstract methods

What is the use of abstract class?
- to achieve abstraction[] hiding the implementation details and providing only functionality.
------------------------------------------------------------------------------------------------------------
interface :
- it is a class which is fully unimplemented class.
- this is a class which contains only abstract methods till java 7.
- from java  8 onwards, interface can contain default and static methods as well.

- By default all the variables in the interface are public static final
- By default, all the methods in the interface are public abstract.

In an interface, we cant have
    - instance variables
    - instance methods
    - instance block
    - constructor

We achieve multiple inheritance with the help of interface.




















Abstract class : it is a class created with abstract keyword
Why do we use abstract class? To write abstract methods
To achieve abstraction.
Abstract method : it is a method which is created without body and with abstract keyword
We can write abstract method inside the abstract class and interface
We can’t create the object of an abstract class interface as abstract stands for incomplete
In an interface we can write all the components from an concrete class plus we can write abstract methods
It is not compulsory to write abstract methods inside the abstract class as well as interface.
abstract class MessageService {
}
We create the subclass and then create the object of subclass then eventually parent abstract class constructor will called.
We can’t achieve multiple inheritance with abstract classes.
We can’t achieve 100% abstraction as we can’t guarantee presence only abstract methods inside the abstract class.
Abstract and final are opposite to each other.
Class cannot be both final and abstract.
Abstract methods are meant for giving override so they cannot be private, final, static
# Interface : it is a fully unimplemented class.
- It contains only abstract methods.
- variables in the interface by default public static final
- methods in the interface by default are public abstract
- as part of an interface we can’t have instance
	- instance variables,
	- instance methods,
	- constructors
	- instance block
	- inner classes
	- static block
These are not allowed because to we can achieve multiple inheritance with interfaces.
One class implements another interface
One class extends another class
One interface extends another interface
* when one concrete class extends an abstract class or implements an interface, then it is compulsory for the concrete class give override for all the abstract methods
* when one one abstract class extends another abstract class or implements an interface then it is optional for the child abstract class to provide implementation
We can’t create object of an abstract class as well as interface.
# Types of interfaces
1. Marker interface : it is an empty interface which is used to marking purpose at runtime
	e.g. Serializable, Cloneable, Auto-closable
2. Function interface :
	- it is interface with only one abstract method. SAM
	- As part of Java 8, functional interface can have any number of default and static methods.
# default methods :
- It is a method which defined inside the java 8 interface with method body and default keyword.
- We use default methods for backward compatibility
- If we introduce a new abstract method inside an interface, then all implementing subclass will break.
- so avoid this, we make the newly introduced abstract method as default with method body. So subclass won’t
# what are the different ways to implement interfaces and abstract class
1. By creating separate concrete subclass by extending abstract class or implementing interface
	abstract class A{}
	class Ample extends A {}
	interface I1{}
	class I1Impl implements I1{}

2. By using anonymous class.
	A a = new A(){//body of the anonymous class};
	I1 I = new I1(){};
# What are the different ways to implement functional interface ?
1. By using separate concrete subclass
2. By using anonymous class
3. By using Lambda expression.
	interface MessageService (){
	void sendMessage ();//SAM
	}
	 MessageService messageService = () -> {SOP(“sending message”)};
# What is a lambda expression?
- it is a new feature in java 8
- it is a concise way of giving implementation of a function interface[SAM].
- It is also called as anonymous function.
- for lambda expression .class file will not be generated.
syntax: FunctionalInterface typeName = (method Params) -> { method implementation};
#Why we use lambda expression?
- we use lambda expression to give implementation for functional interfaces only.
- with lambda we can write concise code.

What are predefined functional interfaces available in Java?
- Runnable, Predicate, Function, Supplier, Consumer, UnaryOperator, BinaryOperator, BinaryConsumer, BiPredicate


# Object:
- It is super class for all the classes in java which are either pre-defined or going to be defined by the developer
- It is called as cosmic class as Object class do not have any parent class
- Object class is a concrete class which contains 11 methods:
- All these methods are regular used to for all the classes.
- All these methods are accessible for all the classes in java.
# methods present in Object class:
      # native methods[code is not written in java]
      public final native java.lang.Class<?> getClass();
      protected native java.lang.Object clone() throws java.lang.CloneNotSupportedException;
      public native int hashCode();

      public boolean equals(java.lang.Object);
      public java.lang.String toString();
      protected void finalize() throws java.lang.Throwable;

     # Methods related to multi-threading
      public final native void notify();
      public final native void notifyAll();
      public final native void wait(long) throws java.lang.InterruptedException;
      public final void wait(long, int) throws java.lang.InterruptedException;
      public final void wait() throws java.lang.InterruptedException;

 # equals();
 - it is a method originally present in Object class.
 - It does the reference check.
 - if reference are equal then it returns true otherwise false.
 - It generally recommended to override equals method.
 - if equals method is overriden then, always call will be given to the child class equals method and not object class

# hashCode();
- it is a method originally present in Object class.
- hashing means converting a bigger value into a smaller value.
- hashFunction takes the bigger a input and generates the hash[small value] for performance improvement
- hashcode method returns a hash i.e. integer value.
- it returns an integer value which is not a direct memory address but a hash calculated based on the original memory address of an object.
- It generally recommended to override hashCode method.
- if hashcode method is overriden then, always call will be given to the child class hashCode method and not object class

***** equals and hashCode contract ***********************
when we say two objects are equal by equals method then there hashCode must be same.



# toString();
- it is a method present Object class from java.lang package
- it returns a string containing the
    - classname: getClass().getName();
    - @
    - hexadecimal value of hashCode

        public String toString() {
            return getClass().getName() + "@" + Integer.toHexString(hashCode());
        }
 - toString method will be called implicitly when we print the reference.

# finalize();
- it is a method present in Object class.
- this method does not have any implementation


# garbage : any unused, unreferenced objects
# garbage collector :
    - It is a daemon thread[program] which is running in background.
    - It cleans or frees the unused memory
    - Before destroying the object it will call the finalize() method.

- finalize() method will be called by garbage collector just before objects gets destroyed.

How to call garbage collector explicitly?
- System.gc();
--------------------------------------------------------------------------------------------------------------

Problems before Array:
1. if we want to store multiple values, we have to create that many variables.
2. managing and accessing also all these variables will be difficult as they are not stored not sequentially.
3. length of the code will increase.

Requirement: To hold multiple values.
1. create that many variables.
2. use array

# What is an Array?
- it is data structure which helps us in storing data of same type in sequential manner.


#Array declaration and initilization:
int[] array;//delcration
array = new int[5];//initilzation

# when we create an array, an object is created inside the heap memory area and inside that object all the variables will be stored sequentially.
e.g. int[] array = new int[5];
    array : reference variable which points to an object
    new int[5]: an object which stores 5 variables

# Can we create an array with size zero?
Ans. Yes we can do. int[] array = new int[0];
    - array is created with zero elements.
    - object is created but no  elements inside that.

# Can we create an array with negative array size?
Ans. if we create an array with negative size we get runtime exception.
      NegativeArraySizeException

# for every array, there will be one variable called length created.
array.length

# To access the array elements we use concept of index.
- Array index starts from 0.
- Array reference always points to the base address where first element is stored.
- to access the array element: array[index].
- Address of an array element = BASE Address + index * data type size;
e.g. first element  = 100 + 0 *4; 100
      second element = 100 + 1 * 4; 104

If we try to access beyond the index, we get ArrayIndexOutOfBoundsException
Index range : 0 to length-1;

# Disadvantages:
1. arrays are fixed in nature. once array is created with specified size then at run time we cant increase or decrease the space
    -There will be either wastage or shortage of memory
2. we cant store heterogeneous[of different data type] data.
3. No built-in method support.
    - For every programming requirement such as searching, sorting, reverse, delete, insert
    developer is responsible.
















